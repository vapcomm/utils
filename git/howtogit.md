## Производственный процесс, или как использовать Git и Gitea в реальной жизни

Здесь описан простой рабочий вариант процесса добавления полезных сущностей в Git-репозиторий.
Сам по себе Git очень разнообразен и сложен, поэтому многие вещи можно делать по-разному,
с использованием разных техник, команд и сторонних утилит. Мы гибки в своих подходах и
можем менять этот процесс, чтобы всем было удобнее и комфортнее в работе. Если есть что добавить
в этот файл, welcome!

**Примечание:** в рабочем процессе описываются шаги для Gitea, примерно то же самое можно делать в GitHub, GitLab и им подобным.


### Настройка Git
Предполагаем, что `git` уже установлен в системе и команда
```shell
git --version
```
выдаёт его версию.

В каждый коммит записывается имя автора и его email, поэтому стоит их заранее настроить:
```shell
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
```
Вместо опции `--global`, которая изменяет конфигурационный файл `~/.gitconfig`, можно использовать `--local`
для настройки локального конфига репозитория в `.git/config`. Эти конфигурационные файлы можно изменять в текстовом редакторе.
Значения в локальном конфиге перетирают значения в глобальном (пользовательском) и системном конфигах, поэтому
если используются разные имена и почтовые адреса для разных репозиториев, то лучше их сохранять в настройках
каждого репозитория.

Для редактирования сообщений в коммитах заранее настраиваем свой любимый текстовый редактор:
```shell
git config --global core.editor mcedit
```
Здесь в качестве примера указан `mcedit`, который входит в состав Midnight Commander.
Редактор так же может задаваться через переменную окружения `GIT_EDITOR`, а если она не задана,
то будет использована `EDITOR` и возможно, вы узнаете, как выходить из `vim`.

### Клонирование репозитория
```shell
cd <каталог с исходниками>
git clone <URL репозитория проекта>
cd <проект>
```
В каталоге проекта будет жить рабочее дерево исходников проекта и git-репозиторий в каталоге `.git`.
Сам по себе репозиторий - это база данных, содержащая файлы проекта и историю их изменений. Вся работа с этой базой
происходит с помощью утилиты `git`, графических утилит типа Sourcetree или плагина к Android Studio/IDEA.

### Локальная донастройка Git
Если для этого репозитория используются другие имя/почта, то настраиваем их до первого коммита:
```shell
git config --local user.name "Jane Doe"
git config --local user.email janedoe@example.com
```

Эти же настройки можно сделать, вручную отредактировав файл `.git/config`, за подробностями см. `man git-config` или документацию по Git.


### Ветки проекта
Если кратко, ветка в Git - это указатель на коммит. Все коммиты связаны в большой направленный граф,
в котором каждый коммит указывает на родительский коммит (или несколько родительских коммитов).
А каждый коммит сам по себе - это полное дерево всех файлов проекта в состоянии на момент коммита.
Коммит в ветку двигает её указатель на этот новый коммит.

- **master** - используем для последней стабильной версии приложения, которую можно отдать заказчику и из неё сделать релиз.
В некоторых политкорректных репозиториях **master** принято называть **main**.
Слияния **master** с **develop** делаются по большим праздникам в присутствии свидетелей в чистой комнате.
- **develop** - рабочая ветка, куда разработчики заливают свои наработки в процессе выполниния задач спринта.
- **wp_<task>** - рабочие "Work in Progress" ветки, создаваемые разработчиками для реализации конкретных задач.
- **f_<task>** - feature ветки, создаваемые на несколько разработчиков для реализации конкретной бизнес-фичи. От неё создаются рабочие wp_ ветки.

### Производственный цикл

**Замечание:** в примере используются консольные команды Git, но все те же действия можно совершать
в графических утилитах или из IDE.

1. Берём задачу из трекера, назначаем её на себя, перевеводим в "In progress" на доске.
2. Декомпозируем T-задачу (task) на подзадачи (issue) в Gitea:
- В заголовке указываем номер родительской задачи (например, T20804)
- Выбираем проект
- По возможности, назначаем задачу на разработчика или на себя
3. Создаём в **Gitea** ветку на новую задачу/подзадачу:

На вкладке **Code** создаём рабочую ветку из **develop**, проще всего это делать на списке веток кнопкой
"Создать новую ветку из develop". Рекомендуется называть рабочие ветки по образцу wp_T20804,
где T20804 - это номер задачи из трекера задач. Ещё можно добавить суффикс с номером подзадачи и парой слов,
чтобы быстро её находить в списке веток: `wp_T208238_19_cameras`. Для больших долгоживущих фиче-веток
рекомендуется их называть с префиксом `f_`, например, `f_T12345_cool_feature`.
Если задача не связана с бизнес-задачами из трекера, то можно использовать префикс wp_ c понятным названием,
которое относится к задаче, например, wp_cool_feature.

В описании Gitea-задачи указываем эту новую ветку.

4. Обновляем локальный репозиторий:
```shell
git fetch
```
в логах команды увидим, что появилась новая ветка, созданная на предыдущем шаге.

**Важно:** `git fetch` не модифицирует рабочий каталог, она только обновляет репозиторий.

**Для справки:** Ветки вида origin/develop и develop - это разные ветки. Первая отслеживает удалённую develop исходного репозитория,
вторая - локальную develop, они совпадают после клонирования репозитория. Команда `git fetch` обновляет базу данных
и двигает origin/develop в соответствии с тем, где она была на удалённом сервере.

5. Переключаемся на рабочую ветку:
```shell
git switch <название ветки>
```
Перед выполнением этой команды и последующих шагов все старые изменения должны быть закоммичены и желательно запушены.
Git обновит все файлы в рабочем каталоге из этой ветки. Если в рабочем каталоге оставались незакоммиченные файлы,
то Git не даст их испортить и переключиться на другую ветку.

6. Пишем много хорошего кода, добавляем новые файлы в рабочий каталог, удаляем лишнее.

7. После того, как весь код написан, тесты пройдены, отладочные логи удалены и приложение опять запускается, готовимся к коммиту.
Смотрим состояние рабочего каталога:
```shell
git status
```
Отобразятся новые и модифицированные файлы. Добавляем их в staging area для последующего коммита:
```shell
git add <имя файла>
```
Ещё раз смотрим `git status`, проверяем, что всё нужное добавлено. В коммит пойдут только те новые или модифицированные файлы,
которые были добавлены в staging area.

8. Делаем коммит:
```shell
git commit
```
Откроется текстовый редактор, в котором мы записываем коммит-сообщение. На первой строке записываем:
номер задачи фабрикатора, через двоеточие номер подзадачи из Gitea (чтобы связать коммит с подзадачей)
и описание изменений в императиве (т.е. описываем действие, а не его последствия). Стараемся уложиться в 50 символов.
Если нужны длинные комментарии, которые не помещаются в одну строку, то второй строкой добавляем пустую строку,
а затем большой текст. Например:

```
T21915: #4 add git examples

Some more cool git examples from real life.
И всё-таки как хорошо писать комментарии к коммитам и в коде на русском языке, это так здорово!
```

**Для справки:** вторая пустая строка может использоваться некоторыми утилитами Git и это правило
полезно соблюдать для всех больших сообщений.

Если сообщение помещается в одну строчку и редактор не нужен, то по-быстрому можно сделать так:
```shell
git commit -m "T00000: add mega feature"
```

Так же можно сразу добавить в коммит все изменённые или удалённые файлы без использования `git add`:
```shell
git commit -a
```
Однако эту комадну следует использовать с осторожностью, чтобы ничего лишнего не попало в коммит.

Коммиты в текущую ветку можно делать сколь угодно много раз, логически разбивая работу по задаче на короткие шаги.
Это потом упростит ревью кода.

**Полезно:** командой `git status -sb` можно посмотреть текущую ветку, куда будет делаться коммит,
и изменения в рабочем каталоге в кратком виде.

Если дрогнула рука и вы заметили опечатку в сообщении последнего коммита, то его можно исправить:
```shell
git commit --amend
```
Последний коммит будет заменён новым со всеми теми же файлами, но новым сообщением.

9. После коммита сразу делаем пуш ветки, чтобы выложить коммит на общий сервер для создания удалённой копии вашего репозитория.

**Важно:** в целях сохранности вашей работы рекомендуется пушить хотя бы раз в день, чтобы иметь,
как минимум, две копии новых исходников проекта на разных носителях.
```shell
git push
```
Если кто-то из коллег уже запушил свой код на эту же ветку, то возникнет ошибка, и Git предложить сначала сделать слияние
с исходной (origin) веткой. Об этом смотрим в разделе "Разруливание конфликтов слияния".

**Полезно:** Чтобы уменьшить количество конфликтов при будущих слияниях, рекомендуется чаще обновлять
код в рабочей ветке из исходной origin/develop:

    git fetch
    git merge origin/develop

10. После завершения работы над задачей и отправки всех коммитов на общий сервер, делаем pull request (PR).
Он нужен для ревью кода другими членами команды. После успешного прохождения ревью
можно будет слить коммиты из рабочей ветки в **develop**.

- В Gitea на вкладке "Запросы на слияния" нажимаем кнопку "Новый запрос на слияние"
- Выбираем: родительскую ветку **develop**, взять из **wp_xxxx**
- Отобразятся все новые коммиты из рабочей ветки и диффы кода. Внимательно проверяем, что всё в порядке,
если нашли проблему, исправляем и коммитим-пушим до создания PR.
- Нажимаем кнопку "Новый запрос на слияние"
- В созданном PR устанавливаем рабочий проект, добавляем необходимых **Рецензентов** из списка.

11. Сообщаем коллегам-рецензентам, чтобы они сделали ревью кода в созданном PR (передать им номер PR или ссылку на него).
Пока ждём code review, можно начать новую задачу в новой ветке.
Если нужно сделать исправления после замечаний, коммитим их в ту же рабочую ветку и пушим её на тот же pull request.

**Важно** Если вы не можете продолжить работу над следующими задачами до слияния ветки с PR в **develop**, попросите коллег
сделать срочный code review, норматив на него - 30 минут. И каждое утро начинаем с проверки свежих PR в Gitea.

12. После успешного code review на Gitea делаем слияние (merge) рабочей ветки в **develop** кнопкой Create merge commit.
Если рабочая ветка больше не нужна, то её можно удалить в Gitea (вручную кнопкой или отметить чекбокс удаления ветки при слиянии).

При необходимости слияние можно сделать вручную:
```shell
git checkout develop
git merge --no-ff wp_xxxx
git push origin develop
```

13. Отмечаем в подзадаче Gitea трудозатраты кнопкой "Добавить время" и если по ней всё сделано, нажимаем кнопку "Закрыть".
14. Если все подзадачи сделаны, то переводим основную задачу в трекере в "Code review" или "Testing".
Если потребуются ещё какие-либо доработки по основной задаче, то переходим на п. 3 или 4.
15. Goto в начало пока не закончатся задачи.


### Слияние (merge)
Сливайтесь чаще, жизнь будет проще!

В идеальной вселенной каждый разработчик сидит на своей ветке и изменяет только свои файлы. Но в реальном мире
несколько разработчиков могут сидеть на одной ветке и исправлять один и тот же файл. Из-за чего наши коммиты
могут конфликтовать с другими и Git не даст запушить изменения. Если возникает ошибка пуша или невозможно слить pull request,
то необходимо вручную обновить код нашей рабочей ветки с удалённого сервера до актуального состояния.

Перед слиянием всегда имеем чистый рабочий каталог, в котором всё закомичено, чтобы можно было легко откатиться назад
при возникновении проблем. Заметим, что сливаются ветки, т.е. конкретные коммиты.

Общий порядок слияния:

`git checkout -b hotfix` -- делаем ветку для исправлений и переключаемся на неё

`git commit -a -m 'Fix some'` -- коммитим исправление в ветку

`git checkout develop` -- возвращаемся на develop

`git merge hotfix` -- делаем слияние develop с hotfix

Если при этом develop не менялся, то будет Fast-forward слияние, просто указатель develop сместится на коммит из ветки hotfix.
Т.е. автоматом делается коммит слияния, у которого два родителя.

При конфликтах слияния автоматического merge-коммита не будет сделано. При этом `git status` покажет файлы с конфликтами.
После ручного разрешения конфликта делаем `git add`, который помечает файлы с конфликтами разрешёнными и добавляет их в staging area.

Если что-то пошло не так, то можно откатить слияние `git merge --abort`.
Эта штука хорошо работает, если перед слиянием всё было закоммичено.

При конфликтах слияния можно посмотреть неслитые файлы через `git ls-files -u`, показываются номера версий файлов,
которые потом можно извлечь и сливать руками, например, через kdiff3 или `git merge-file -p`.
Stage 1 - это общий предок, stage 2 - это наша версия, stage 3 - это MERGE_HEAD, версия, которая сливается с нашей, т.е. "theirs".

### Разруливание конфликтов слияния
Если при создании pull request Gitea показывает, что есть конфликты с **develop**, то нужно слить рабочую ветку с **develop** и устранить конфликты:
1. Обновляем репозиторий
```shell
git fetch
```
2. Переключаемся на рабочую ветку, если стоим не на ней:
```shell
git checkout <название ветки>
```
3. Сливаемся с удалённой веткой **origin/develop**
```shell
 git merge origin/develop
```
4. Если в результате слияния возникли конфликты, мы можем их разрешить вручную в текстовом редакторе или при помощи графической утилиты 
(например, можно использовать kdiff3):
```shell
git mergetool --tool=kdiff3
```
5. Команда запустит kdiff3 где мы можем разрешить все конфликты. Рекомендуется смотреть все изменения в файле,
которые делает kdiff3, а не только конфликты.

> Замечание: Команда `git mergetool --tool-help` позволит посмотреть другие утилиты для разрешения конфликтов, которые поддерживаются git.

6. После разрешения конфлитов необходимо добавить все файлы в staging area:
```shell
git add .
```
7. Делаем коммит:
```shell
git commit -m "Merge wp_t20804 with develop"
```
Если делать коммит без -m, в текстовом редакторе git сам добавит подсказку о слиянии с нужными именами веток.

8. Пушим в репозиторий:
```shell
git push
```
9. Обновляем в Gitea страницу PR, появится зеленая кнопка "Create merge commit", дальше действуем как при обычном PR.


### Полезные команды Git

#### Ветки

`git branch` -- смотреть список веток, текущая отмечена звёздочкой и зелёным цветом

`git branch -a` -- показывает список всех веток, локальные и удалённые

`git branch -vv` -- показывает ветки с их источниками и насколько они отстают/опережают удалённый
репозиторий. `ahead` в статистике ветки означает количество локальных коммитов,
которые ещё не запушены на удалённую ветку. `behind` - сколько коммитов на серверной ветке,
которые мы не затянули в нашу локальную ветку. Эти счётчики показывают значения после последнего `git fetch`
и не отражают реального значения в реалтайме.

`git switch <newbranch>` -- переключится на новую ветку

`git checkout [<branch>]` -- переключить файлы в рабочем каталоге на указанную ветку (или текущую, если не задано имени)

`git branch -d hotfix` -- удалить ветку hotfix

##### Создать удалённую ветку
```shell
git fetch; git switch develop; git pull
git checkout -b <banch_name>
git push -u origin <banch_name>
```

#### Коммиты

`git reset --soft HEAD~1` -- отмена одного предыдущего коммита, при этом рабочие файлы остаются не тронутыми.

`git log --oneline` -- перед `git reset --soft` полезно посмотреть, куда показывает HEAD (последний коммит)

`git difftool --tool-help` -- показывает, какие средства для графического сравнения файлов доступны в системе,
чтобы не просто `git diff` в терминале запускать, а красивые диффы разглядывать.

`git log master..develop` -- разница между ветками, все коммиты, доступные с develop, но которые не доступны с master

`git log origin/<ветка>..HEAD` -- посмотреть, какие коммиты сейчас будут пушиться на удалённую ветку

`git diff --check` -- полезно перед коммитом делать проверку на trailing whitespace

`git ls-tree -r HEAD` -- список всех файлов в HEAD с их хэшами.

##### Откат последнего коммита на origin сервере, для примера main-ветка

```shell
git reset --soft HEAD^
git push origin +main --force
```
Подробности этого метода см.: https://stackoverflow.com/questions/448919/how-can-i-remove-a-commit-on-github

#### Слияния

`git mergetool`	-- запускает графическую утилиту для разрешения конфликтов, которая прописана в конфиге Git.

`git checkout --ours hello.rb` -- взять нашу версию файла после ошибки слияния

`git log --oneline --left-right --merge` -- посмотреть список коммитов, которые использовались при слиянии с конфликтом


### Архивация исходников
Иногда надо передать исходники в виде архива (без Git-репозитория), создать его можно командой:
```shell
git archive develop -o mm-2022-05-17-develop.tgz --prefix='mobile-multiplatform/'
```
* develop -- какую ветку паковать
* -o -- задаёт имя файла, без неё выдаёт архив на stdout, по расширению может определить формат архива
* --prefix -- имя корневого каталога в архиве (надо обязательно задавать в апострофах и в конце ставить слэш)

В целях информационной безопасности рекомендуется хранить исходники как минимум в трёх копиях на разных
носителях разной физической природы и территориально разнесённых. Например, храним копию архива на SSD рабочей машины,
на внешнем винчестере, на флэшке в ~~столе~~ сейфе и на сервере компании.

Распределённая архитектура Git позволяет легко следовать этому правилу, т.к. каждый клон репозитория практически
равнозначен тому, что есть на общем Git-сервере и при необходимости может заменить его с минимальными потерями.
